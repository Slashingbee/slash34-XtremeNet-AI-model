require 'nn'
require 'math'
-- We initialize the model
model = nn.Sequential()

-- We add an input layer to generate images 3 is the number of channels (R, G and B) and 1920*1080 is the size of the image in pixels(by default full HD).
model:add(nn.Linear(3 * 1920 * 1080, 10000))

-- We add hidden layers with LeakyReLU activation
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))
model:add(nn.LeakyReLU(negative_slope=math.random(0.0001, 1))))

-- we add Linear calculation layers
model:add(nn.Linear(2496, 10))
model:add(nn.Linear(4869, 2496))
model:add(nn.Linear(6869, 3496))
model:add(nn.Linear(8959, 6493))
model:add(nn.Linear(10869, 9596))
model:add(nn.Linear(46968, 23484))

-- we add finish neural layer *this model uses basic Linear layers in the nn library*
model:add(nn.Linear(86968, 53484))
-- We initialize the model weights with random values
model:apply(weights_init('kaiming'))

-- we choose loose function *this model uses MSE*
criterion = nn.MSECriterion()


-- we define a optimalisator *for this model SGD is used*
optimizer = optim.SGD(model.parameters(), lr=0.00001)
-- we load a word list *remove if not needed*
inputs = {}
labels = {}

local usedTrainDataPath = "UsedTrainData"
for file in fs.list(usedTrainDataPath) do
  if string.sub(file, -4) ~= ".TEMP" then
    table.insert(inputs, fs.readFile(usedTrainDataPath .. "/" .. file))
    local label = string.sub(file, 1, -5)
    table.insert(labels, label)
-- loop (epochs) *learning loop*
for i = 1, 1000 do
-- we download learning DATA
  local inputs, labels = getTrainingData()
wait 100
  local inputs, labels = getTrainingData2()

-- we are setting gradients to defaults
optimizer:zeroGrad()

-- We pass data through the model and calculate the loss
  local outputs = model:eval(inputs)
